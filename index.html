<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>JRegexPlus by Karthik Jayaraman</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>JRegexPlus</h1>
          <h2>Regular Expression engine - Backreferences without backtracking</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/karthikj1/JRegexPlus/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/karthikj1/JRegexPlus/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/karthikj1/JRegexPlus" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <p>This is a proof of concept Regular Expression engine that handles sub-match grouping and back-references without backtracking. See <a href = "UserGuide.html">here</a> for a User Guide, <a href="https://github.com/karthikj1/JRegexPlus_Tester">here</a> for a test suite that can be used to test the engine and <a href="Algorithm.html">here</a> for a short explanation of how it achieves this. If there are any questions, I can be contacted at karthik_jayaraman at msn dot com.</p>

<p><em><strong>What it does</strong></em></p>

<p>This is a full-fledged regular expression engine written in Java. It is unique in that it is a one-pass NFA engine <em>without</em> backtracking that can handle back-references, reluctant quantifiers, provide sub-match groupings and process lookaround operators with arbitrary embedded regular expressions(including variable-length operators like + and *). The ability to handle back-references without backtracking or multiple passes is unique among publicly available regular expression engines - including popular ones like Perl, PCRE or java.util.regex and goes against the popular belief that only backtracking implementations can handle backreferences.</p>

<p><em><strong>What it includes</strong></em></p>

<p>It handles most constructs supported by the java.util.regex engine as described below except for those outlined <a href = "#not_included">here</a>. </p>

<p> Additional features</p>
<ul>
<li> Backreferences are processed without backtracking or multiple passes. 
<p></p>
<li> Lookbehind operator can handle arbitrary regular expressions including + and * operators but not backreferences. Lookaround does use a second pass over the input at the point where the lookaround begins. 
</ul>

<p>Advantages and disadvantages</p>
<ul>
<li> The primary advantage of a non-backtracking implementation is the performance improvement in cases that would cause a backtracking engine to hang. Compared to a DFA, this implementation also supports submatch grouping, backreferences and lookaround with arbitrary regular expressions.
<p></p>
<li> The general problem of matching regexes that include backreferences is NP-hard so it is still possible to construct combinations of regular expressions and text that will cause exponential blowup. However, this engine's technique has the advantage of other Thompson NFA implementations in that expressions without backreferences will not create exponential blowup. As a result, the number of corner cases with backreferences that blowup the engine are also fewer.
<p></p>
<li> The results honour POSIX-style left-most longest matching. Given the expression (nfa|nfa karthik) on a string "nfa karthik", a traditional nfa will match just nfa. JRegexPlus will match "nfa karthik".
<p></p>
<li> For simple regexes, the processing speed is competitive though not necessarily the fastest. However, this has more to do with the fact that this is meant as a proof of concept demo to show that backreferences can work without backtracking and not as a production regex engine. The core algorithm can be expected to perform comparably to a backtracking implementation in normal cases while continuing to respond fast in cases that would make a backtracker hang.
</ul>

<p></p>
 <h4> Summary of JRegexPlus regular-expression constructs </h4>

 <table border="0" cellpadding="1" cellspacing="0"
  summary="Regular expression constructs, and what they match">

 <tr align="left">
 <th bgcolor="#CCCCFF" align="left" id="construct">Construct</th>
 <th bgcolor="#CCCCFF" align="center" id="matches">Matches</th>
 </tr>

 <tr><th>&nbsp;</th></tr>
 <tr align="left"><th colspan="2" id="characters">Characters</th></tr>

 <tr><td valign="top" headers="construct characters"><i>x</i></td>
     <td headers="matches">The character <i>x</i></td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\\</tt></td>
     <td headers="matches">The backslash character</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\0</tt><i>mnn</i></td>
     <td headers="matches">The character with octal value <tt>0</tt><i>mnn</i>
         (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>m</i>&nbsp;<tt>&lt;=</tt>&nbsp;3,
         0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\x</tt><i>hh</i></td>
     <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hh</i></td></tr>
 <tr><td valign="top" headers="matches"><tt>\t</tt></td>
     <td headers="matches">The tab character (<tt>'&#92;u0009'</tt>)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\n</tt></td>
     <td headers="matches">The newline (line feed) character (<tt>'&#92;u000A'</tt>)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\r</tt></td>
     <td headers="matches">The carriage-return character (<tt>'&#92;u000D'</tt>)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\f</tt></td>
     <td headers="matches">The form-feed character (<tt>'&#92;u000C'</tt>)</td></tr>

 <tr><th>&nbsp;</th></tr>
 <tr align="left"><th colspan="2" id="classes">Character classes</th></tr>

 <tr><td valign="top" headers="construct classes"><tt>[abc]</tt></td>
     <td headers="matches"><tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (simple class)</td></tr>
 <tr><td valign="top" headers="construct classes"><tt>[^abc]</tt></td>
     <td headers="matches">Any character except <tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (negation)</td></tr>
 <tr><td valign="top" headers="construct classes"><tt>[a-zA-Z]</tt></td>
     <td headers="matches"><tt>a</tt> through <tt>z</tt>
         or <tt>A</tt> through <tt>Z</tt>, inclusive (range)</td></tr>
 <tr><td valign="top" headers="construct classes"><tt>[a-d[m-p]]</tt></td>
     <td headers="matches"><tt>a</tt> through <tt>d</tt>,
      or <tt>m</tt> through <tt>p</tt>: <tt>[a-dm-p]</tt> (union)</td></tr>
 <tr><td valign="top" headers="construct classes"><tt>[a-z&&[def]]</tt></td>
     <td headers="matches"><tt>d</tt>, <tt>e</tt>, or <tt>f</tt> (intersection)</tr>
 <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^bc]]</tt></td>
     <td headers="matches"><tt>a</tt> through <tt>z</tt>,
         except for <tt>b</tt> and <tt>c</tt>: <tt>[ad-z]</tt> (subtraction)</td></tr>
 <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^m-p]]</tt></td>
     <td headers="matches"><tt>a</tt> through <tt>z</tt>,
          and not <tt>m</tt> through <tt>p</tt>: <tt>[a-lq-z]</tt>(subtraction)</td></tr>
 <tr><th>&nbsp;</th></tr>

 <tr align="left"><th colspan="2" id="predef">Predefined character classes</th></tr>

 <tr><td valign="top" headers="construct predef"><tt>.</tt></td>
     <td headers="matches">Any character (may or may not match line terminators)</td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\d</tt></td>
     <td headers="matches">A digit: <tt>[0-9]</tt></td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\D</tt></td>
     <td headers="matches">A non-digit: <tt>[^0-9]</tt></td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\s</tt></td>
     <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\S</tt></td>
     <td headers="matches">A non-whitespace character: <tt>[^\s]</tt></td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\w</tt></td>
     <td headers="matches">A word character: <tt>[a-zA-Z_0-9]</tt></td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\W</tt></td>
     <td headers="matches">A non-word character: <tt>[^\w]</tt></td></tr>

 <tr><th>&nbsp;</th></tr>
 <tr align="left"><th colspan="2" id="posix">POSIX character classes</b> (US-ASCII only)<b></th></tr>

 <tr><td valign="top" headers="construct posix"><tt>\p{Lower}</tt></td>
     <td headers="matches">A lower-case alphabetic character: <tt>[a-z]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Upper}</tt></td>
     <td headers="matches">An upper-case alphabetic character:<tt>[A-Z]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{ASCII}</tt></td>
     <td headers="matches">All ASCII:<tt>[\x00-\x7F]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Alpha}</tt></td>
     <td headers="matches">An alphabetic character:<tt>[\p{Lower}\p{Upper}]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Digit}</tt></td>
     <td headers="matches">A decimal digit: <tt>[0-9]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Alnum}</tt></td>
     <td headers="matches">An alphanumeric character:<tt>[\p{Alpha}\p{Digit}]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Punct}</tt></td>
     <td headers="matches">Punctuation: One of <tt>!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~</tt></td></tr>
     <!-- <tt>[\!"#\$%&'\(\)\*\+,\-\./:;\<=\>\?@\[\\\]\^_`\{\|\}~]</tt>
          <tt>[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]</tt> -->
 <tr><td valign="top" headers="construct posix"><tt>\p{Graph}</tt></td>
     <td headers="matches">A visible character: <tt>[\p{Alnum}\p{Punct}]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Print}</tt></td>
     <td headers="matches">A printable character: <tt>[\p{Graph}\x20]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Blank}</tt></td>
     <td headers="matches">A space or a tab: <tt>[ \t]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Cntrl}</tt></td>
     <td headers="matches">A control character: <tt>[\x00-\x1F\x7F]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{XDigit}</tt></td>
     <td headers="matches">A hexadecimal digit: <tt>[0-9a-fA-F]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Space}</tt></td>
     <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\P{&lt;classname&gt;}</tt></td>
     <td headers="matches">Negated POSIX class &lt;classname&gt; </td></tr>

 <tr><th>&nbsp;</th></tr>
 <tr align="left"><th colspan="2" id="bounds">Boundary matchers</th></tr>

 <tr><td valign="top" headers="construct bounds"><tt>^</tt></td>
     <td headers="matches">The beginning of a line</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>$</tt></td>
     <td headers="matches">The end of a line</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\b</tt></td>
     <td headers="matches">A word boundary</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\B</tt></td>
     <td headers="matches">A non-word boundary</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\A</tt></td>
     <td headers="matches">The beginning of the input</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\Z</tt></td>
     <td headers="matches">The end of the input but for the final terminator, if&nbsp;any</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\z</tt></td>
     <td headers="matches">The end of the input</td></tr>

 <tr><th>&nbsp;</th></tr>
 <tr align="left"><th colspan="2" id="greedy">Greedy quantifiers</th></tr>

 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>?</tt></td>
     <td headers="matches"><i>X</i>, once or not at all</td></tr>
 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>*</tt></td>
     <td headers="matches"><i>X</i>, zero or more times</td></tr>
 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>+</tt></td>
     <td headers="matches"><i>X</i>, one or more times</td></tr>
 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>}</tt></td>
     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,}</tt></td>
     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt></td>
     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>

<tr><th>&nbsp;</th></tr>
 <tr align="left"><th colspan="2" id="reluc">Reluctant quantifiers</th></tr>

 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>??</tt></td>
     <td headers="matches"><i>X</i>, once or not at all</td></tr>
 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>*?</tt></td>
     <td headers="matches"><i>X</i>, zero or more times</td></tr>
 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>+?</tt></td>
     <td headers="matches"><i>X</i>, one or more times</td></tr>
 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>}?</tt></td>
     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,}?</tt></td>
     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}?</tt></td>
     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>

 <tr><th>&nbsp;</th></tr>
 <tr align="left"><th colspan="2" id="logical">Logical operators</th></tr>

 <tr><td valign="top" headers="construct logical"><i>XY</i></td>
     <td headers="matches"><i>X</i> followed by <i>Y</i></td></tr>
 <tr><td valign="top" headers="construct logical"><i>X</i><tt>|</tt><i>Y</i></td>
     <td headers="matches">Either <i>X</i> or <i>Y</i></td></tr>
 <tr><td valign="top" headers="construct logical"><tt>(</tt><i>X</i><tt>)</tt></td>
     <td headers="matches">X, as a capturing group</td></tr>

 <tr><th>&nbsp;</th></tr>
 <tr align="left"><th colspan="2" id="backref">Back references</th></tr>

 <tr><td valign="bottom" headers="construct backref"><tt>\</tt><i>n</i></td>
     <td valign="bottom" headers="matches">Whatever the <i>n</i><sup>th</sup>
     capturing group matched (0 < n < 10)</td></tr>
<tr><td valign="bottom" headers="construct backref"><tt>\</tt><i>k</i>&lt;<i>name</i>&gt;</td>
     <td valign="bottom" headers="matches">Whatever the named-capturing group "name" matched</td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="special">Special constructs</th></tr>
<tr><td valign="top" headers="construct special"><tt>(?&lt;name&gt;</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, as a named-capturing group</td></tr>
   <tr><td valign="top" headers="construct special"><tt>(?=</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, via zero-width positive lookahead</td></tr>
 <tr><td valign="top" headers="construct special"><tt>(?!</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, via zero-width negative lookahead</td></tr>
 <tr><td valign="top" headers="construct special"><tt>(?&lt;=</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, via zero-width positive lookbehind</td></tr>
 <tr><td valign="top" headers="construct special"><tt>(?&lt;!</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, via zero-width negative lookbehind</td></tr>

 </table>
<p></p>
<a name = "not_included"></a>
<p><em><strong>What's not included</strong></em></p>

<p>Atomic grouping and possessive quantifiers are not supported but are not necessary since they are primarily a way to work around issues created by backtracking. </p>

<p>Non-capturing groups are not supported since they do not provide a significant performance advantage with this engine's method of operation.</p>

<p>The boundary matcher \G is not supported in regexes but the Matcher class searches starting at the end of the previous match by default so the same functionality is available. </p>

<p>UNICODE characters and UNICODE character classes are not yet supported.</p>

<p>Quotations - \Q and \E are not yet supported.</p>

<p>Java.util.regex supports various flags - only case-sensitive, comment and the newline related flags are relevant in the absence of UNICODE support but are not yet supported by this engine. The default mode is CASE_INSENSITIVE off, UNIX_LINES and DOTALL modes on</p>

<hr>
        </section>

        <footer>
          JRegexPlus is maintained by <a href="https://github.com/karthikj1">karthikj1</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
